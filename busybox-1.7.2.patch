diff -uprN busybox-1.7.2/Config.in busybox-1.7.2-smack/Config.in
--- busybox-1.7.2/Config.in	2007-09-03 04:48:58.000000000 -0700
+++ busybox-1.7.2-smack/Config.in	2008-05-27 21:33:33.000000000 -0700
@@ -222,6 +222,13 @@ config SELINUX
 
 	  Most people will leave this set to 'N'.
 
+config SMACK
+	bool "Support Smack"
+	default n
+	help
+	  Enable support for Smack in applets ls, ps, and id.  Also provide
+	  the option of compiling in Smack applets.
+
 config FEATURE_PREFER_APPLETS
 	bool "exec prefers applets"
 	default n
@@ -506,4 +513,5 @@ source shell/Config.in
 source sysklogd/Config.in
 source runit/Config.in
 source selinux/Config.in
+source smack/Config.in
 source ipsvd/Config.in
diff -uprN busybox-1.7.2/coreutils/id.c busybox-1.7.2-smack/coreutils/id.c
--- busybox-1.7.2/coreutils/id.c	2007-09-03 04:48:40.000000000 -0700
+++ busybox-1.7.2-smack/coreutils/id.c	2008-05-27 21:33:33.000000000 -0700
@@ -22,6 +22,9 @@
 #if ENABLE_SELINUX
 #define JUST_CONTEXT     16
 #endif
+#if ENABLE_SMACK
+#define JUST_CONTEXT     16
+#endif
 
 static int printf_full(unsigned int id, const char *arg, const char prefix)
 {
@@ -47,10 +50,21 @@ int id_main(int argc, char **argv)
 #if ENABLE_SELINUX
 	security_context_t scontext;
 #endif
+#if ENABLE_SMACK
+	char smack[80];
+#endif
 	/* Don't allow -n -r -nr -ug -rug -nug -rnug */
 	/* Don't allow more than one username */
-	opt_complementary = "?1:u--g:g--u:r?ug:n?ug" USE_SELINUX(":u--Z:Z--u:g--Z:Z--g");
-	flags = getopt32(argv, "rnug" USE_SELINUX("Z"));
+#if ENABLE_SELINUX
+	opt_complementary = "?1:u--g:g--u:r?ug:n?ug:u--Z:Z--u:g--Z:Z--g";
+	flags = getopt32(argv, "rnugZ");
+#elif ENABLE_SMACK
+	opt_complementary = "?1:u--g:g--u:r?ug:n?ug:u--Z:Z--u:g--Z:Z--g";
+	flags = getopt32(argv, "rnugZ");
+#else
+	opt_complementary = "?1:u--g:g--u:r?ug:n?ug";
+	flags = getopt32(argv, "rnug");
+#endif
 
 	/* This values could be overwritten later */
 	uid = geteuid();
@@ -68,7 +82,13 @@ int id_main(int argc, char **argv)
 		/* in this case PRINT_REAL is the same */
 	}
 
-	if (flags & (JUST_GROUP | JUST_USER USE_SELINUX(| JUST_CONTEXT))) {
+#if ENABLE_SELINUX
+	if (flags & (JUST_GROUP | JUST_USER | JUST_CONTEXT)) {
+#elif ENABLE_SMACK
+	if (flags & (JUST_GROUP | JUST_USER | JUST_CONTEXT)) {
+#else
+	if (flags & (JUST_GROUP | JUST_USER )) {
+#endif
 		/* JUST_GROUP and JUST_USER are mutually exclusive */
 		if (flags & NAME_NOT_NUMBER) {
 			/* bb_getXXXid(-1) exit on failure, puts cannot segfault */
@@ -95,6 +115,18 @@ int id_main(int argc, char **argv)
 			printf("%s\n", scontext);
 		}
 #endif
+#if ENABLE_SMACK
+		if (flags & JUST_CONTEXT) {
+			if (argc - optind == 1) {
+				bb_error_msg_and_die("user name can't be passed with -Z");
+			}
+
+			if (smack_from_proc(-1, smack, sizeof(smack)) < 0) {
+				bb_error_msg_and_die("can't get process context");
+			}
+			printf("%s\n", smack);
+		}
+#endif
 		/* exit */
 		fflush_stdout_and_exit(EXIT_SUCCESS);
 	}
@@ -120,6 +152,10 @@ int id_main(int argc, char **argv)
 		printf(" context=%s", context);
 	}
 #endif
+#if ENABLE_SMACK
+	smack_from_proc(-1, smack, sizeof(smack));
+	printf(" smack=\"%s\"", smack);
+#endif
 
 	putchar('\n');
 	fflush_stdout_and_exit(status);
diff -uprN busybox-1.7.2/coreutils/ls.c busybox-1.7.2-smack/coreutils/ls.c
--- busybox-1.7.2/coreutils/ls.c	2007-09-03 04:48:40.000000000 -0700
+++ busybox-1.7.2-smack/coreutils/ls.c	2008-05-27 21:33:33.000000000 -0700
@@ -66,12 +66,12 @@ LIST_EXEC       = 1 << 14,
 LIST_MASK       = (LIST_EXEC << 1) - 1,
 
 /* what files will be displayed */
-DISP_DIRNAME    = 1 << 15,      /* 2 or more items? label directories */
-DISP_HIDDEN     = 1 << 16,      /* show filenames starting with . */
-DISP_DOT        = 1 << 17,      /* show . and .. */
-DISP_NOLIST     = 1 << 18,      /* show directory as itself, not contents */
-DISP_RECURSIVE  = 1 << 19,      /* show directory and everything below it */
-DISP_ROWS       = 1 << 20,      /* print across rows */
+DISP_DIRNAME    = 1 << 16,      /* 2 or more items? label directories */
+DISP_HIDDEN     = 1 << 17,      /* show filenames starting with . */
+DISP_DOT        = 1 << 18,      /* show . and .. */
+DISP_NOLIST     = 1 << 19,      /* show directory as itself, not contents */
+DISP_RECURSIVE  = 1 << 20,      /* show directory and everything below it */
+DISP_ROWS       = 1 << 21,      /* print across rows */
 DISP_MASK       = ((DISP_ROWS << 1) - 1) & ~(DISP_DIRNAME - 1),
 
 /* how will the files be sorted (CONFIG_FEATURE_LS_SORTFILES) */
@@ -136,6 +136,7 @@ struct dnode {                  /* the b
 	int   allocated;
 	struct stat dstat;      /* the file stat info */
 	USE_SELINUX(security_context_t sid;)
+	USE_SMACK(char xattr[80];)
 	struct dnode *next;     /* point at the next node */
 };
 typedef struct dnode dnode_t;
@@ -163,6 +164,10 @@ static struct dnode *my_stat(const char 
 	struct stat dstat;
 	struct dnode *cur;
 	USE_SELINUX(security_context_t sid = NULL;)
+#if ENABLE_SMACK
+	char xattr[80];
+	int i;
+#endif
 
 	if ((all_fmt & FOLLOW_LINKS) || force_follow) {
 #if ENABLE_SELINUX
@@ -170,6 +175,11 @@ static struct dnode *my_stat(const char 
 			 getfilecon(fullname, &sid);
 		}
 #endif
+#if ENABLE_SMACK
+		i = smack_from_file(fullname, xattr, 80, 1);
+		if (i < 0)
+			xattr[0] = '\0';
+#endif
 		if (stat(fullname, &dstat)) {
 			bb_perror_msg("%s", fullname);
 			status = EXIT_FAILURE;
@@ -181,6 +191,11 @@ static struct dnode *my_stat(const char 
 			lgetfilecon(fullname, &sid);
 		}
 #endif
+#if ENABLE_SMACK
+		i = smack_from_file(fullname, xattr, 80, 0);
+		if (i < 0)
+			xattr[0] = '\0';
+#endif
 		if (lstat(fullname, &dstat)) {
 			bb_perror_msg("%s", fullname);
 			status = EXIT_FAILURE;
@@ -193,6 +208,7 @@ static struct dnode *my_stat(const char 
 	cur->name = name;
 	cur->dstat = dstat;
 	USE_SELINUX(cur->sid = sid;)
+	USE_SMACK(strncpy(cur->xattr, xattr, 80);)
 	return cur;
 }
 
@@ -402,6 +418,7 @@ static void showfiles(struct dnode **dn,
 		}
 		column_width += tabstops +
 			USE_SELINUX( ((all_fmt & LIST_CONTEXT) ? 33 : 0) + )
+			USE_SMACK(   ((all_fmt & LIST_CONTEXT) ? 24 : 0) + )
 			             ((all_fmt & LIST_INO) ? 8 : 0) +
 			             ((all_fmt & LIST_BLOCKS) ? 5 : 0);
 		ncols = (int) (terminal_width / column_width);
@@ -651,6 +668,14 @@ static int list_single(struct dnode *dn)
 			}
 			break;
 #endif
+#if ENABLE_SMACK
+		case LIST_CONTEXT:
+			{
+				printf("%-23s ", dn->xattr);
+				column += MAX(24, strlen(dn->xattr) + 1);
+			}
+			break;
+#endif
 		case LIST_FILENAME:
 			errno = 0;
 #if ENABLE_FEATURE_LS_COLOR
@@ -719,8 +744,10 @@ static const char ls_options[] ALIGN1 =
 	USE_FEATURE_LS_RECURSIVE("R")
 	USE_FEATURE_HUMAN_READABLE("h")
 	USE_SELINUX("K")
+	USE_SMACK("K")
 	USE_FEATURE_AUTOWIDTH("T:w:")
-	USE_SELINUX("Z");
+	USE_SELINUX("Z")
+	USE_SMACK("Z");
 
 enum {
 	LIST_MASK_TRIGGER	= 0,
@@ -741,7 +768,12 @@ static const unsigned opt_flags[] = {
 	LIST_BLOCKS,                /* s */
 	DISP_ROWS,                  /* x */
 	DISP_HIDDEN,                /* A */
-	ENABLE_SELINUX * LIST_CONTEXT, /* k (ignored if !SELINUX) */
+#if ENABLE_SELINUX
+	LIST_CONTEXT,               /* k (ignored if !SELINUX) */
+#endif
+#if ENABLE_SMACK
+	LIST_CONTEXT,               /* k (ignored if !SMACK) */
+#endif
 #if ENABLE_FEATURE_LS_TIMESTAMPS
 	TIME_CHANGE | (ENABLE_FEATURE_LS_SORTFILES * SORT_CTIME),   /* c */
 	LIST_FULLTIME,              /* e */
@@ -770,12 +802,18 @@ static const unsigned opt_flags[] = {
 #if ENABLE_SELINUX
 	LIST_MODEBITS|LIST_NLINKS|LIST_CONTEXT|LIST_SIZE|LIST_DATE_TIME, /* K */
 #endif
+#if ENABLE_SMACK
+	LIST_MODEBITS|LIST_NLINKS|LIST_CONTEXT|LIST_SIZE|LIST_DATE_TIME, /* K */
+#endif
 #if ENABLE_FEATURE_AUTOWIDTH
 	0, 0,                       /* T, w - ignored */
 #endif
 #if ENABLE_SELINUX
 	LIST_MODEBITS|LIST_ID_NAME|LIST_CONTEXT, /* Z */
 #endif
+#if ENABLE_SMACK
+	LIST_MODEBITS|LIST_ID_NAME|LIST_CONTEXT, /* Z */
+#endif
 	(1U<<31)
 };
 
diff -uprN busybox-1.7.2/coreutils/stat.c busybox-1.7.2-smack/coreutils/stat.c
--- busybox-1.7.2/coreutils/stat.c	2007-09-03 04:48:40.000000000 -0700
+++ busybox-1.7.2-smack/coreutils/stat.c	2008-06-02 10:24:25.000000000 -0700
@@ -20,6 +20,7 @@
 #define OPT_TERSE		(1<<1)
 #define OPT_DEREFERENCE	(1<<2)
 #define OPT_SELINUX		(1<<3)
+#define OPT_SMACK		(1<<3)
 
 static char buf[sizeof("YYYY-MM-DD HH:MM:SS.000000000")] ALIGN1;
 
@@ -119,7 +120,8 @@ static char const *human_fstype(long f_t
 /* print statfs info */
 static void print_statfs(char *pformat, const size_t buf_len, const char m,
 			 const char *const filename, void const *data
-			 USE_SELINUX(, security_context_t scontext))
+			 USE_SELINUX(, security_context_t scontext)
+			 USE_SMACK(, char *smack))
 {
 	struct statfs const *statfsbuf = data;
 	if (m == 'n') {
@@ -160,6 +162,11 @@ static void print_statfs(char *pformat, 
 		strncat(pformat, "s", buf_len);
 		printf(scontext);
 #endif
+#if ENABLE_SMACK
+	} else if (m == 'C' && (option_mask32 & OPT_SMACK)) {
+		strncat(pformat, "s", buf_len);
+		printf(smack);
+#endif
 	} else {
 		strncat(pformat, "c", buf_len);
 		printf(pformat, m);
@@ -169,7 +176,8 @@ static void print_statfs(char *pformat, 
 /* print stat info */
 static void print_stat(char *pformat, const size_t buf_len, const char m,
 		       const char *const filename, void const *data
-			   USE_SELINUX(, security_context_t scontext))
+			   USE_SELINUX(, security_context_t scontext)
+			   USE_SMACK(, char *smack))
 {
 #define TYPE_SIGNED(t) (! ((t) 0 < (t) -1))
 	struct stat *statbuf = (struct stat *) data;
@@ -275,16 +283,33 @@ static void print_stat(char *pformat, co
 		strncat(pformat, "s", buf_len);
 		printf(pformat, scontext);
 #endif
+#if ENABLE_SMACK
+	} else if (m == 'C' && (option_mask32 & OPT_SMACK)) {
+		strncat(pformat, "s", buf_len);
+		printf(pformat, smack);
+#endif
 	} else {
 		strncat(pformat, "c", buf_len);
 		printf(pformat, m);
 	}
 }
 
+#if ENABLE_SELINUX
+static void print_it(char const *masterformat, char const *filename,
+		     void (*print_func) (char *, size_t, char, char const *,
+				void const *, security_context_t scontext),
+			 void const *data, security_context_t scontext)
+#elif ENABLE_SMACK
 static void print_it(char const *masterformat, char const *filename,
-		     void (*print_func) (char *, size_t, char, char const *, void const *
-								 USE_SELINUX(, security_context_t scontext)),
-					 void const *data USE_SELINUX(, security_context_t scontext) )
+		     void (*print_func) (char *, size_t, char, char const *,
+				void const *, char *smack),
+			 void const *data, char *smack)
+#else
+static void print_it(char const *masterformat, char const *filename,
+		     void (*print_func) (char *, size_t, char, char const *,
+				void const *),
+			 void const *data)
+#endif
 {
 	char *b;
 
@@ -324,7 +349,8 @@ static void print_it(char const *masterf
 			putchar('%');
 			break;
 		default:
-			print_func(dest, n_alloc, *p, filename, data USE_SELINUX(,scontext));
+			print_func(dest, n_alloc, *p, filename, data
+				USE_SELINUX(,scontext) USE_SMACK(,smack));
 			break;
 		}
 	}
@@ -352,6 +378,18 @@ static bool do_statfs(char const *filena
 		}
 	}
 #endif
+#if ENABLE_SMACK
+	char smack[SMACKBUFFSIZE];
+
+	if (option_mask32 & OPT_SMACK) {
+		int i = option_mask32 & OPT_DEREFERENCE;
+
+		if (smack_from_file(filename, smack, sizeof(smack), i) < 0) {
+			bb_perror_msg(filename);
+			return 0;
+		}
+	}
+#endif
 	if (statfs(filename, &statfsbuf) != 0) {
 		bb_perror_msg("cannot read file system information for '%s'", filename);
 		return 0;
@@ -359,16 +397,7 @@ static bool do_statfs(char const *filena
 
 #if ENABLE_FEATURE_STAT_FORMAT
 	if (format == NULL)
-#if !ENABLE_SELINUX
-		format = (option_mask32 & OPT_TERSE
-			? "%n %i %l %t %s %b %f %a %c %d\n"
-			: "  File: \"%n\"\n"
-			  "    ID: %-8i Namelen: %-7l Type: %T\n"
-			  "Block size: %-10s\n"
-			  "Blocks: Total: %-10b Free: %-10f Available: %a\n"
-			  "Inodes: Total: %-10c Free: %d");
-	print_it(format, filename, print_statfs, &statfsbuf USE_SELINUX(, scontext));
-#else
+#if ENABLE_SELINUX
 	format = (option_mask32 & OPT_TERSE
 			? (option_mask32 & OPT_SELINUX ? "%n %i %l %t %s %b %f %a %c %d %C\n":
 			"%n %i %l %t %s %b %f %a %c %d\n")
@@ -385,8 +414,36 @@ static bool do_statfs(char const *filena
 			"Blocks: Total: %-10b Free: %-10f Available: %a\n"
 			"Inodes: Total: %-10c Free: %d\n")
 			);
-	print_it(format, filename, print_statfs, &statfsbuf USE_SELINUX(, scontext));
+	print_it(format, filename, print_statfs, &statfsbuf, scontext);
+#elif ENABLE_SMACK
+	format = (option_mask32 & OPT_TERSE
+			? (option_mask32 & OPT_SMACK ? "%n %i %l %t %s %b %f %a %c %d %C\n":
+			"%n %i %l %t %s %b %f %a %c %d\n")
+			: (option_mask32 & OPT_SMACK ?
+			"  File: \"%n\"\n"
+			"    ID: %-8i Namelen: %-7l Type: %T\n"
+			"Block size: %-10s\n"
+			"Blocks: Total: %-10b Free: %-10f Available: %a\n"
+			"Inodes: Total: %-10c Free: %d"
+			"  Smack: %C\n":
+			"  File: \"%n\"\n"
+			"    ID: %-8i Namelen: %-7l Type: %T\n"
+			"Block size: %-10s\n"
+			"Blocks: Total: %-10b Free: %-10f Available: %a\n"
+			"Inodes: Total: %-10c Free: %d\n")
+			);
+	print_it(format, filename, print_statfs, &statfsbuf, smack);
+#else
+		format = (option_mask32 & OPT_TERSE
+			? "%n %i %l %t %s %b %f %a %c %d\n"
+			: "  File: \"%n\"\n"
+			  "    ID: %-8i Namelen: %-7l Type: %T\n"
+			  "Block size: %-10s\n"
+			  "Blocks: Total: %-10b Free: %-10f Available: %a\n"
+			  "Inodes: Total: %-10c Free: %d");
+	print_it(format, filename, print_statfs, &statfsbuf);
 #endif /* SELINUX */
+
 #else /* FEATURE_STAT_FORMAT */
 	format = (option_mask32 & OPT_TERSE
 		? "%s %llx %lu "
@@ -402,20 +459,7 @@ static bool do_statfs(char const *filena
 	else
 		printf("Type: %s\n", human_fstype(statfsbuf.f_type));
 
-#if !ENABLE_SELINUX
-	format = (option_mask32 & OPT_TERSE
-		? "%lu %ld %ld %ld %ld %ld\n"
-		: "Block size: %-10lu\n"
-		  "Blocks: Total: %-10jd Free: %-10jd Available: %jd\n"
-		  "Inodes: Total: %-10jd Free: %jd\n");
-	printf(format,
-	       (unsigned long) (statfsbuf.f_bsize),
-	       (intmax_t) (statfsbuf.f_blocks),
-	       (intmax_t) (statfsbuf.f_bfree),
-	       (intmax_t) (statfsbuf.f_bavail),
-	       (intmax_t) (statfsbuf.f_files),
-	       (intmax_t) (statfsbuf.f_ffree));
-#else
+#if ENABLE_SELINUX
 	format = (option_mask32 & OPT_TERSE
 		? (option_mask32 & OPT_SELINUX ? "%lu %ld %ld %ld %ld %ld %C\n":
 		"%lu %ld %ld %ld %ld %ld\n")
@@ -438,7 +482,41 @@ static bool do_statfs(char const *filena
 
 	if (scontext)
 		freecon(scontext);
+#elif ENABLE_SMACK
+	format = (option_mask32 & OPT_TERSE
+		? (option_mask32 & OPT_SMACK ? "%lu %ld %ld %ld %ld %ld %C\n":
+		"%lu %ld %ld %ld %ld %ld\n")
+		: (option_mask32 & OPT_SMACK ?
+		"Block size: %-10lu\n"
+		"Blocks: Total: %-10jd Free: %-10jd Available: %jd\n"
+		"Inodes: Total: %-10jd Free: %jd"
+		"Smack: %C\n":
+		"Block size: %-10lu\n"
+		"Blocks: Total: %-10jd Free: %-10jd Available: %jd\n"
+		"Inodes: Total: %-10jd Free: %jd\n"));
+	printf(format,
+	       (unsigned long) (statfsbuf.f_bsize),
+	       (intmax_t) (statfsbuf.f_blocks),
+	       (intmax_t) (statfsbuf.f_bfree),
+	       (intmax_t) (statfsbuf.f_bavail),
+	       (intmax_t) (statfsbuf.f_files),
+	       (intmax_t) (statfsbuf.f_ffree),
+		smack);
+#else
+	format = (option_mask32 & OPT_TERSE
+		? "%lu %ld %ld %ld %ld %ld\n"
+		: "Block size: %-10lu\n"
+		  "Blocks: Total: %-10jd Free: %-10jd Available: %jd\n"
+		  "Inodes: Total: %-10jd Free: %jd\n");
+	printf(format,
+	       (unsigned long) (statfsbuf.f_bsize),
+	       (intmax_t) (statfsbuf.f_blocks),
+	       (intmax_t) (statfsbuf.f_bfree),
+	       (intmax_t) (statfsbuf.f_bavail),
+	       (intmax_t) (statfsbuf.f_files),
+	       (intmax_t) (statfsbuf.f_ffree));
 #endif
+
 #endif	/* FEATURE_STAT_FORMAT */
 	return 1;
 }
@@ -461,6 +539,18 @@ static bool do_stat(char const *filename
 		}
 	}
 #endif
+#if ENABLE_SMACK
+	char smack[SMACKBUFFSIZE];
+
+	if (option_mask32 & OPT_SMACK) {
+		int i = option_mask32 & OPT_DEREFERENCE;
+
+		if (smack_from_file(filename, smack, sizeof(smack), i) < 0) {
+			bb_perror_msg(filename);
+			return 0;
+		}
+	}
+#endif
 	if ((option_mask32 & OPT_DEREFERENCE ? stat : lstat) (filename, &statbuf) != 0) {
 		bb_perror_msg("cannot stat '%s'", filename);
 		return 0;
@@ -468,41 +558,56 @@ static bool do_stat(char const *filename
 
 #if ENABLE_FEATURE_STAT_FORMAT
 	if (format == NULL) {
-#if !ENABLE_SELINUX
+#if ENABLE_SELINUX
 		if (option_mask32 & OPT_TERSE) {
-			format = "%n %s %b %f %u %g %D %i %h %t %T %X %Y %Z %o";
+			format = (option_mask32 & OPT_SELINUX ?
+				  "%n %s %b %f %u %g %D %i %h %t %T %X %Y %Z %o %C\n":
+				  "%n %s %b %f %u %g %D %i %h %t %T %X %Y %Z %o\n");
 		} else {
 			if (S_ISBLK(statbuf.st_mode) || S_ISCHR(statbuf.st_mode)) {
-				format =
-					"  File: \"%N\"\n"
-					"  Size: %-10s\tBlocks: %-10b IO Block: %-6o %F\n"
-					"Device: %Dh/%dd\tInode: %-10i  Links: %-5h"
-					" Device type: %t,%T\n"
-					"Access: (%04a/%10.10A)  Uid: (%5u/%8U)   Gid: (%5g/%8G)\n"
-					"Access: %x\n" "Modify: %y\n" "Change: %z\n";
+				format = (option_mask32 & OPT_SELINUX ?
+					  "  File: \"%N\"\n"
+					  "  Size: %-10s\tBlocks: %-10b IO Block: %-6o %F\n"
+					  "Device: %Dh/%dd\tInode: %-10i  Links: %-5h"
+					  " Device type: %t,%T\n"
+					  "Access: (%04a/%10.10A)  Uid: (%5u/%8U)   Gid: (%5g/%8G)\n"
+					  "   S_Context: %C\n"
+					  "Access: %x\n" "Modify: %y\n" "Change: %z\n":
+					  "  File: \"%N\"\n"
+					  "  Size: %-10s\tBlocks: %-10b IO Block: %-6o %F\n"
+					  "Device: %Dh/%dd\tInode: %-10i  Links: %-5h"
+					  " Device type: %t,%T\n"
+					  "Access: (%04a/%10.10A)  Uid: (%5u/%8U)   Gid: (%5g/%8G)\n"
+					  "Access: %x\n" "Modify: %y\n" "Change: %z\n");
 			} else {
-				format =
-					"  File: \"%N\"\n"
-					"  Size: %-10s\tBlocks: %-10b IO Block: %-6o %F\n"
-					"Device: %Dh/%dd\tInode: %-10i  Links: %h\n"
-					"Access: (%04a/%10.10A)  Uid: (%5u/%8U)   Gid: (%5g/%8G)\n"
-					"Access: %x\n" "Modify: %y\n" "Change: %z\n";
+				format = (option_mask32 & OPT_SELINUX ?
+					  "  File: \"%N\"\n"
+					  "  Size: %-10s\tBlocks: %-10b IO Block: %-6o %F\n"
+					  "Device: %Dh/%dd\tInode: %-10i  Links: %h\n"
+					  "Access: (%04a/%10.10A)  Uid: (%5u/%8U)   Gid: (%5g/%8G)\n"
+					  "S_Context: %C\n"
+					  "Access: %x\n" "Modify: %y\n" "Change: %z\n":
+					  "  File: \"%N\"\n"
+					  "  Size: %-10s\tBlocks: %-10b IO Block: %-6o %F\n"
+					  "Device: %Dh/%dd\tInode: %-10i  Links: %h\n"
+					  "Access: (%04a/%10.10A)  Uid: (%5u/%8U)   Gid: (%5g/%8G)\n"
+					  "Access: %x\n" "Modify: %y\n" "Change: %z\n");
 			}
 		}
-#else
+#elif ENABLE_SMACK
 		if (option_mask32 & OPT_TERSE) {
-			format = (option_mask32 & OPT_SELINUX ?
+			format = (option_mask32 & OPT_SMACK ?
 				  "%n %s %b %f %u %g %D %i %h %t %T %X %Y %Z %o %C\n":
 				  "%n %s %b %f %u %g %D %i %h %t %T %X %Y %Z %o\n");
 		} else {
 			if (S_ISBLK(statbuf.st_mode) || S_ISCHR(statbuf.st_mode)) {
-				format = (option_mask32 & OPT_SELINUX ?
+				format = (option_mask32 & OPT_SMACK ?
 					  "  File: \"%N\"\n"
 					  "  Size: %-10s\tBlocks: %-10b IO Block: %-6o %F\n"
 					  "Device: %Dh/%dd\tInode: %-10i  Links: %-5h"
 					  " Device type: %t,%T\n"
 					  "Access: (%04a/%10.10A)  Uid: (%5u/%8U)   Gid: (%5g/%8G)\n"
-					  "   S_Context: %C\n"
+					  "   Smack: %C\n"
 					  "Access: %x\n" "Modify: %y\n" "Change: %z\n":
 					  "  File: \"%N\"\n"
 					  "  Size: %-10s\tBlocks: %-10b IO Block: %-6o %F\n"
@@ -511,12 +616,12 @@ static bool do_stat(char const *filename
 					  "Access: (%04a/%10.10A)  Uid: (%5u/%8U)   Gid: (%5g/%8G)\n"
 					  "Access: %x\n" "Modify: %y\n" "Change: %z\n");
 			} else {
-				format = (option_mask32 & OPT_SELINUX ?
+				format = (option_mask32 & OPT_SMACK ?
 					  "  File: \"%N\"\n"
 					  "  Size: %-10s\tBlocks: %-10b IO Block: %-6o %F\n"
 					  "Device: %Dh/%dd\tInode: %-10i  Links: %h\n"
 					  "Access: (%04a/%10.10A)  Uid: (%5u/%8U)   Gid: (%5g/%8G)\n"
-					  "S_Context: %C\n"
+					  "Smack: %C\n"
 					  "Access: %x\n" "Modify: %y\n" "Change: %z\n":
 					  "  File: \"%N\"\n"
 					  "  Size: %-10s\tBlocks: %-10b IO Block: %-6o %F\n"
@@ -525,13 +630,46 @@ static bool do_stat(char const *filename
 					  "Access: %x\n" "Modify: %y\n" "Change: %z\n");
 			}
 		}
+#else
+		if (option_mask32 & OPT_TERSE) {
+			format = "%n %s %b %f %u %g %D %i %h %t %T %X %Y %Z %o";
+		} else {
+			if (S_ISBLK(statbuf.st_mode) || S_ISCHR(statbuf.st_mode)) {
+				format =
+					"  File: \"%N\"\n"
+					"  Size: %-10s\tBlocks: %-10b IO Block: %-6o %F\n"
+					"Device: %Dh/%dd\tInode: %-10i  Links: %-5h"
+					" Device type: %t,%T\n"
+					"Access: (%04a/%10.10A)  Uid: (%5u/%8U)   Gid: (%5g/%8G)\n"
+					"Access: %x\n" "Modify: %y\n" "Change: %z\n";
+			} else {
+				format =
+					"  File: \"%N\"\n"
+					"  Size: %-10s\tBlocks: %-10b IO Block: %-6o %F\n"
+					"Device: %Dh/%dd\tInode: %-10i  Links: %h\n"
+					"Access: (%04a/%10.10A)  Uid: (%5u/%8U)   Gid: (%5g/%8G)\n"
+					"Access: %x\n" "Modify: %y\n" "Change: %z\n";
+			}
+		}
 #endif
+
 	}
-	print_it(format, filename, print_stat, &statbuf USE_SELINUX(, scontext));
+#if ENABLE_SELINUX
+	print_it(format, filename, print_stat, &statbuf, scontext);
+#elif ENABLE_SMACK
+	print_it(format, filename, print_stat, &statbuf, smack);
+#else
+	print_it(format, filename, print_stat, &statbuf);
+#endif
+
 #else	/* FEATURE_STAT_FORMAT */
 	if (option_mask32 & OPT_TERSE) {
 		printf("%s %ju %ju %lx %lu %lu %jx %ju %lu %lx %lx %lu %lu %lu %lu"
-		       SKIP_SELINUX("\n"),
+#if !ENABLE_SELINUX && !ENABLE_SMACK
+		       "\n",
+#else
+		       "",
+#endif
 		       filename,
 		       (uintmax_t) (statbuf.st_size),
 		       (uintmax_t) statbuf.st_blocks,
@@ -554,6 +692,12 @@ static bool do_stat(char const *filename
 		else
 			putchar('\n');
 #endif
+#if ENABLE_SMACK
+		if (option_mask32 & OPT_SMACK)
+			printf(" %lc\n", smack[0]);
+		else
+			putchar('\n');
+#endif
 	} else {
 		char *linkname = NULL;
 
@@ -597,6 +741,9 @@ static bool do_stat(char const *filename
 #if ENABLE_SELINUX
 		printf("   S_Context: %lc\n", *scontext);
 #endif
+#if ENABLE_SMACK
+		printf("   Smack: %lc\n", smack[0]);
+#endif
 		printf("Access: %s\n" "Modify: %s\n" "Change: %s\n",
 		       human_time(statbuf.st_atime),
 		       human_time(statbuf.st_mtime),
@@ -616,6 +763,7 @@ int stat_main(int argc, char **argv)
 
 	getopt32(argv, "ftL"
 		USE_SELINUX("Z")
+		USE_SMACK("Z")
 		USE_FEATURE_STAT_FORMAT("c:", &format)
 	);
 
diff -uprN busybox-1.7.2/findutils/Config.in busybox-1.7.2-smack/findutils/Config.in
--- busybox-1.7.2/findutils/Config.in	2007-09-03 04:48:54.000000000 -0700
+++ busybox-1.7.2-smack/findutils/Config.in	2008-06-02 09:54:01.000000000 -0700
@@ -167,7 +167,7 @@ config FEATURE_FIND_REGEX
 config FEATURE_FIND_CONTEXT
 	bool "Enable (-context) option for matching security context"
 	default n
-	depends on FIND && SELINUX
+	depends on FIND && (SELINUX || SMACK)
 	help
 	  Support the 'find -context' option for matching security context.
 
diff -uprN busybox-1.7.2/findutils/find.c busybox-1.7.2-smack/findutils/find.c
--- busybox-1.7.2/findutils/find.c	2007-09-29 16:54:12.000000000 -0700
+++ busybox-1.7.2-smack/findutils/find.c	2008-06-02 10:02:40.000000000 -0700
@@ -88,7 +88,12 @@ USE_FEATURE_FIND_NEWER(  ACTS(newer, tim
 USE_FEATURE_FIND_INUM(   ACTS(inum,  ino_t inode_num;))
 USE_FEATURE_FIND_USER(   ACTS(user,  uid_t uid;))
 USE_FEATURE_FIND_SIZE(   ACTS(size,  char size_char; off_t size;))
+#if ENABLE_SELINUX
 USE_FEATURE_FIND_CONTEXT(ACTS(context, security_context_t context;))
+#endif
+#if ENABLE_SMACK
+USE_FEATURE_FIND_CONTEXT(ACTS(context, char context[SMACKBUFFSIZE];))
+#endif
 USE_FEATURE_FIND_PAREN(  ACTS(paren, action ***subexpr;))
 USE_FEATURE_FIND_PRUNE(  ACTS(prune))
 USE_FEATURE_FIND_DELETE( ACTS(delete))
@@ -354,6 +359,14 @@ ACTF(delete)
 #if ENABLE_FEATURE_FIND_CONTEXT
 ACTF(context)
 {
+#if ENABLE_SMACK
+	char smack[SMACKBUFFSIZE];
+
+	if (smack_from_file(fileName, smack, SMACKBUFFSIZE,
+						(recurse_flags & ACTION_FOLLOWLINKS) ? 1 : 0) < 0)
+		return FALSE;
+	return strcmp(ap->context, smack) == 0;
+#else
 	security_context_t con;
 	int rc;
 
@@ -367,6 +380,7 @@ ACTF(context)
 	rc = strcmp(ap->context, con);
 	freecon(con);
 	return rc == 0;
+#endif
 }
 #endif
 
@@ -777,10 +791,15 @@ static action*** parse_params(char **arg
 		else if (parm == PARM_context) {
 			action_context *ap;
 			ap = ALLOC_ACTION(context);
+#if ENABLE_SELINUX
 			ap->context = NULL;
 			/* SELinux headers erroneously declare non-const parameter */
 			if (selinux_raw_to_trans_context((char*)arg1, &ap->context))
 				bb_perror_msg("%s", arg1);
+#endif
+#if ENABLE_SMACK
+			strcpy(ap->context, arg1);
+#endif
 		}
 #endif
 		else {
diff -uprN busybox-1.7.2/include/applets.h busybox-1.7.2-smack/include/applets.h
--- busybox-1.7.2/include/applets.h	2007-09-03 04:48:46.000000000 -0700
+++ busybox-1.7.2-smack/include/applets.h	2008-05-27 21:33:33.000000000 -0700
@@ -242,6 +242,7 @@ USE_MV(APPLET(mv, _BB_DIR_BIN, _BB_SUID_
 USE_NAMEIF(APPLET(nameif, _BB_DIR_SBIN, _BB_SUID_NEVER))
 USE_NC(APPLET(nc, _BB_DIR_USR_BIN, _BB_SUID_NEVER))
 USE_NETSTAT(APPLET(netstat, _BB_DIR_BIN, _BB_SUID_NEVER))
+USE_NEWSMACK(APPLET(newsmack, _BB_DIR_USR_SBIN, _BB_SUID_NEVER))
 USE_NICE(APPLET(nice, _BB_DIR_BIN, _BB_SUID_NEVER))
 USE_NMETER(APPLET(nmeter, _BB_DIR_USR_BIN, _BB_SUID_NEVER))
 USE_NOHUP(APPLET(nohup, _BB_DIR_USR_BIN, _BB_SUID_NEVER))
@@ -302,6 +303,9 @@ USE_FEATURE_SH_IS_MSH(APPLET_NOUSAGE(sh,
 USE_SHA1SUM(APPLET_ODDNAME(sha1sum, md5_sha1_sum, _BB_DIR_USR_BIN, _BB_SUID_NEVER, sha1sum))
 USE_SLATTACH(APPLET(slattach, _BB_DIR_SBIN, _BB_SUID_NEVER))
 USE_SLEEP(APPLET_NOFORK(sleep, sleep, _BB_DIR_BIN, _BB_SUID_NEVER, sleep))
+USE_SMACKCIPSO(APPLET(smackcipso, _BB_DIR_USR_SBIN, _BB_SUID_NEVER))
+USE_SMACKENABLED(APPLET(smackenabled, _BB_DIR_USR_SBIN, _BB_SUID_NEVER))
+USE_SMACKLOAD(APPLET(smackload, _BB_DIR_USR_SBIN, _BB_SUID_NEVER))
 USE_SOFTLIMIT(APPLET_ODDNAME(softlimit, chpst, _BB_DIR_USR_BIN, _BB_SUID_NEVER, softlimit))
 USE_SORT(APPLET_NOEXEC(sort, sort, _BB_DIR_USR_BIN, _BB_SUID_NEVER, sort))
 USE_SPLIT(APPLET(split, _BB_DIR_USR_BIN, _BB_SUID_NEVER))
diff -uprN busybox-1.7.2/include/libbb.h busybox-1.7.2-smack/include/libbb.h
--- busybox-1.7.2/include/libbb.h	2007-09-16 11:48:10.000000000 -0700
+++ busybox-1.7.2-smack/include/libbb.h	2008-05-30 10:37:19.000000000 -0700
@@ -45,6 +45,13 @@
 #include <selinux/context.h>
 #endif
 
+#if ENABLE_SMACK
+#define	SMACKBUFFSIZE	24
+#define SMACKATTR		"security.SMACK64"
+#define SMACKFLOOR		"_"
+#define SMACKSTAR		"*"
+#endif
+
 #if ENABLE_LOCALE_SUPPORT
 #include <locale.h>
 #else
@@ -784,6 +791,15 @@ extern context_t set_security_context_co
 						char *user, char *role, char *type, char *range);
 extern void setfscreatecon_or_die(security_context_t scontext);
 #endif
+#if ENABLE_SMACK
+extern int smack_from_file(const char *path, char *result, int len, int follow);
+extern int smack_from_proc(const int pid, char *result, int len);
+extern int smack_to_file(const char *path, const char *smack, int follow);
+extern int smack_to_proc(const int pid, const char *smack);
+extern int smack_user_default(const char *user, char *result, int len);
+extern int smack_user_allowed(const char *user, const char *smack);
+extern int smack_user_add(const char *user, const char *smack);
+#endif
 extern void selinux_or_die(void);
 extern int restricted_shell(const char *shell);
 extern void setup_environment(const char *shell, int loginshell, int changeenv, const struct passwd *pw);
@@ -889,6 +905,7 @@ typedef struct {
 	char *argv0;
 	/*char *exe;*/
 	USE_SELINUX(char *context;)
+	USE_SMACK(char context[SMACKBUFFSIZE];)
 	/* Everything below must contain no ptrs to malloc'ed data:
 	 * it is memset(0) for each process in procps_scan() */
 	unsigned vsz, rss; /* we round it to kbytes */
@@ -924,6 +941,7 @@ enum {
 	PSSCAN_UTIME    = 1 << 13,
 	PSSCAN_TTY      = 1 << 14,
 	USE_SELINUX(PSSCAN_CONTEXT  = 1 << 15,)
+	USE_SMACK(PSSCAN_CONTEXT  = 1 << 15,)
 	/* These are all retrieved from proc/NN/stat in one go: */
 	PSSCAN_STAT     = PSSCAN_PPID | PSSCAN_PGID | PSSCAN_SID
 	                | PSSCAN_COMM | PSSCAN_STATE
@@ -1012,6 +1030,9 @@ extern const char bb_path_gshadow_file[]
 extern const char bb_path_group_file[];
 extern const char bb_path_motd_file[];
 extern const char bb_path_wtmp_file[];
+#if ENABLE_SMACK
+extern const char bb_path_smack_user[];
+#endif
 extern const char bb_dev_null[];
 extern const char bb_busybox_exec_path[];
 /* util-linux manpage says /sbin:/bin:/usr/sbin:/usr/bin,
diff -uprN busybox-1.7.2/include/usage.h busybox-1.7.2-smack/include/usage.h
--- busybox-1.7.2/include/usage.h	2007-09-03 04:48:46.000000000 -0700
+++ busybox-1.7.2-smack/include/usage.h	2008-05-27 21:33:33.000000000 -0700
@@ -1391,6 +1391,9 @@
 	USE_SELINUX( \
        "	-Z	prints only the security context\n" \
 	) \
+	USE_SMACK( \
+       "	-Z	prints only the security label\n" \
+	) \
        "	-g	Prints only the group ID\n" \
        "	-u	Prints only the user ID\n" \
        "	-n	Print a name instead of a number\n" \
@@ -2456,6 +2459,11 @@
      "\n	-W	Display with no column truncation" \
 	)
 
+#define newsmack_trivial_usage \
+       "label [COMMAND [ARG] ...]"
+#define newsmack_full_usage \
+       "Run a program or shell with the specified Smack label" \
+
 #define nice_trivial_usage \
        "[-n ADJUST] [COMMAND [ARG] ...]"
 #define nice_full_usage \
@@ -2668,7 +2676,7 @@
 
 #else /* !ENABLE_DESKTOP */
 
-#if !defined CONFIG_SELINUX && !ENABLE_FEATURE_PS_WIDE
+#if !defined CONFIG_SELINUX && !ENABLE_FEATURE_PS_WIDE && !defined CONFIG_SMACK
 #define USAGE_PS "\nThis version of ps accepts no options"
 #else
 #define USAGE_PS "\nOptions:"
@@ -2681,6 +2689,8 @@
 	USAGE_PS \
 	USE_SELINUX( \
        "\n	-Z	Show SE Linux context") \
+	USE_SMACK( \
+       "\n	-Z	Show Smack label") \
 	USE_FEATURE_PS_WIDE( \
        "\n	w	Wide output")
 
@@ -3081,6 +3091,17 @@ USE_FEATURE_RUN_PARTS_FANCY("\n	-l	Print
        "$ sleep 1d 3h 22m 8s\n" \
        "[98528 second delay results]\n")
 
+#define smackcipso_trivial_usage
+#define smackcipso_full_usage \
+       "Read and set Smack CIPSO mappings from the standard input"
+
+#define smackenabled_trivial_usage
+#define smackenabled_full_usage
+
+#define smackload_trivial_usage
+#define smackload_full_usage \
+       "Read and set Smack access rules from the standard input"
+
 #define sort_trivial_usage \
        "[-nru" \
 	USE_FEATURE_SORT_BIG("gMcszbdfimSTokt] [-o outfile] [-k start[.offset][opts][,end[.offset][opts]] [-t char") \
@@ -3174,6 +3195,9 @@ USE_FEATURE_RUN_PARTS_FANCY("\n	-l	Print
 	USE_SELINUX( \
        "\n	-Z	Print security context" \
 	) \
+	USE_SMACK( \
+       "\n	-Z	Print Smack label" \
+	) \
 	USE_FEATURE_STAT_FORMAT( \
        "\n\nValid format sequences for files:\n" \
        " %a	Access rights in octal\n" \
@@ -3211,6 +3235,9 @@ USE_FEATURE_RUN_PARTS_FANCY("\n	-l	Print
 	USE_SELINUX( \
        " %C	Security context in SELinux\n" \
 	) \
+	USE_SMACK( \
+       " %C	Smack label\n" \
+	) \
        " %i	File System ID in hex\n" \
        " %l	Maximum length of filenames\n" \
        " %n	File name\n" \
diff -uprN busybox-1.7.2/libbb/Kbuild busybox-1.7.2-smack/libbb/Kbuild
--- busybox-1.7.2/libbb/Kbuild	2007-09-03 04:48:41.000000000 -0700
+++ busybox-1.7.2-smack/libbb/Kbuild	2008-05-27 21:33:33.000000000 -0700
@@ -112,6 +112,7 @@ lib-$(CONFIG_LOGIN) += correct_password.
 lib-$(CONFIG_DF) += find_mount_point.o
 lib-$(CONFIG_MKFS_MINIX) += find_mount_point.o
 lib-$(CONFIG_SELINUX) += selinux_common.o
+lib-$(CONFIG_SMACK) += smack_common.o
 
 # We shouldn't build xregcomp.c if we don't need it - this ensures we don't
 # require regex.h to be in the include dir even if we don't need it thereby
diff -uprN busybox-1.7.2/libbb/messages.c busybox-1.7.2-smack/libbb/messages.c
--- busybox-1.7.2/libbb/messages.c	2007-09-03 04:48:42.000000000 -0700
+++ busybox-1.7.2-smack/libbb/messages.c	2008-05-29 18:30:11.000000000 -0700
@@ -34,6 +34,9 @@ const char bb_path_shadow_file[] ALIGN1 
 const char bb_path_group_file[] ALIGN1 = "/etc/group";
 const char bb_path_gshadow_file[] ALIGN1 = "/etc/gshadow";
 const char bb_path_motd_file[] ALIGN1 = "/etc/motd";
+#if ENABLE_SMACK
+const char bb_path_smack_user[] ALIGN1 = "/etc/smack/user";
+#endif
 const char bb_dev_null[] ALIGN1 = "/dev/null";
 const char bb_busybox_exec_path[] ALIGN1 = CONFIG_BUSYBOX_EXEC_PATH;
 const char bb_default_login_shell[] ALIGN1 = LIBBB_DEFAULT_LOGIN_SHELL;
diff -uprN busybox-1.7.2/libbb/procps.c busybox-1.7.2-smack/libbb/procps.c
--- busybox-1.7.2/libbb/procps.c	2007-09-03 04:48:41.000000000 -0700
+++ busybox-1.7.2-smack/libbb/procps.c	2008-05-27 21:33:33.000000000 -0700
@@ -173,6 +173,12 @@ procps_status_t *procps_scan(procps_stat
 				sp->context = NULL;
 		}
 #endif
+#if ENABLE_SMACK
+		if (flags & PSSCAN_CONTEXT) {
+			if (smack_from_proc(sp->pid, sp->context, SMACKBUFFSIZE) < 0)
+				strcpy(sp->context, "?");
+		}
+#endif
 
 		filename_tail = filename + sprintf(filename, "/proc/%d", pid);
 
diff -uprN busybox-1.7.2/libbb/smack_common.c busybox-1.7.2-smack/libbb/smack_common.c
--- busybox-1.7.2/libbb/smack_common.c	1969-12-31 16:00:00.000000000 -0800
+++ busybox-1.7.2-smack/libbb/smack_common.c	2008-05-29 18:29:55.000000000 -0700
@@ -0,0 +1,179 @@
+/*
+ * libbb/smack_common.c
+ *   -- common Smack utility functions
+ *
+ * Copyright 2007 Casey Schaufler <casey@schaufler-ca.com>
+ */
+#include "libbb.h"
+#include <attr/xattr.h>
+
+#define	SMACKPROCPATH	"/proc/%d/attr/current"
+#define SMACKUSERFILE	"/etc/smack/user"
+#define SMACKFILELINE	256
+
+int smack_from_file(const char *path, char *result, int len, int follow)
+{
+	char buffer[SMACKBUFFSIZE];
+	int rc;
+
+	if (follow)
+		rc = getxattr(path, SMACKATTR, buffer, SMACKBUFFSIZE - 1);
+	else
+		rc = lgetxattr(path, SMACKATTR, buffer, SMACKBUFFSIZE - 1);
+
+	if (rc < 0)
+		return rc;
+
+	buffer[rc] = '\0';
+	if (strlen(buffer) > len)
+		return -EINVAL;
+
+	strcpy(result, buffer);
+	return rc;
+}
+
+int smack_from_proc(const int pid, char *result, int len)
+{
+	char path[SMACKFILELINE];
+	char buffer[SMACKFILELINE];
+	int fd;
+	int i;
+
+	sprintf(path, SMACKPROCPATH, (pid < 0) ? getpid() : pid);
+
+	fd = open(path, O_RDONLY);
+	if (fd < 0)
+		return -EACCES;
+
+	i = read(fd, buffer, SMACKFILELINE);
+	close(fd);
+
+	if (i <= 0 || i >= len)
+		return -ERANGE;
+	buffer[i] = '\0';
+	strcpy(result, buffer);
+	return 0;
+}
+
+int smack_to_file(const char *path, const char *smack, int follow)
+{
+	if (follow)
+		return setxattr(path, SMACKATTR, smack, strlen(smack)+1, 0);
+	return lsetxattr(path, SMACKATTR, smack, strlen(smack)+1, 0);
+}
+
+int smack_to_proc(const int pid, const char *smack)
+{
+	char path[SMACKFILELINE];
+	int fd;
+	int i;
+	int slen;
+
+	slen = strlen(smack) + 1;
+	if (slen >= SMACKBUFFSIZE)
+		return -ERANGE;
+
+	sprintf(path, SMACKPROCPATH, (pid < 0) ? getpid() : pid);
+
+	fd = open(path, O_RDWR);
+	if (fd < 0)
+		return -EACCES;
+
+	i = write(fd, smack, slen);
+	close(fd);
+
+	if (i != slen)
+		return -EINVAL;
+	return 0;
+}
+
+int smack_user_default(const char *user, char *result, int len)
+{
+	char line[SMACKFILELINE];
+	char ruser[SMACKFILELINE];
+	char rsmack[SMACKFILELINE];
+	FILE *fp;
+
+	fp = fopen(bb_path_smack_user, "r");
+	if (fp == NULL)
+		return -ENOENT;
+
+	while (fgets(line, SMACKFILELINE, fp) != NULL) {
+		if (line[0] == '#' || line[0] == '\n')
+			continue;
+		if (sscanf(line, "%s %s", ruser, rsmack) != 2)
+			continue;
+		if (strcmp(ruser, user) != 0)
+			continue;
+		if (strlen(rsmack) >= len)
+			return -ERANGE;
+		strcpy(result, rsmack);
+		return 0;
+	}
+	return -ENOENT;
+}
+
+int smack_user_allowed(const char *user, const char *smack)
+{
+	char line[SMACKFILELINE];
+	char *ruser;
+	char *rsmack;
+	FILE *fp;
+	int rc = 1;
+
+	fp = fopen(SMACKUSERFILE, "r");
+	if (fp == NULL)
+		return -ENOENT;
+
+	while (rc == 1 && fgets(line, SMACKFILELINE, fp) != NULL) {
+		if (line[0] == '#' || line[0] == '\n')
+			continue;
+
+		ruser = strtok(line, " \t\n");
+		if (ruser == NULL)
+			continue;
+
+		if (strcmp(ruser, user) != 0)
+			continue;
+
+		while (rc == 1 && (rsmack = strtok(NULL, " \t\n")) != NULL) {
+			if (strcmp(rsmack, smack) == 0 || strcmp(rsmack, "+") == 0)
+				rc = 0;
+		}
+	}
+	fclose(fp);
+	return (rc == 1) ? -ENOENT : rc;
+}
+
+int smack_user_add(const char *user, const char *smack)
+{
+	char line[SMACKFILELINE];
+	char *ruser;
+	char *rsmack;
+	FILE *fp;
+	int rc = 0;
+
+	fp = fopen(SMACKUSERFILE, "a+");
+	if (fp == NULL)
+		return -ENOENT;
+
+	while (fgets(line, SMACKFILELINE, fp) != NULL) {
+		if (line[0] == '#' || line[0] == '\n')
+			continue;
+
+		ruser = strtok(line, " \t\n");
+		if (ruser == NULL)
+			continue;
+
+		if (strcmp(ruser, user) == 0) {
+			rc = -EEXIST;
+			break;
+		}
+	}
+
+	if (rc == 0)
+		fprintf(fp, "%s %s\n", user, smack);
+
+	fclose(fp);
+	return rc;
+}
diff -uprN busybox-1.7.2/loginutils/adduser.c busybox-1.7.2-smack/loginutils/adduser.c
--- busybox-1.7.2/loginutils/adduser.c	2007-09-03 04:48:47.000000000 -0700
+++ busybox-1.7.2-smack/loginutils/adduser.c	2008-05-30 10:39:17.000000000 -0700
@@ -170,6 +170,9 @@ int adduser_main(int argc, char **argv)
 {
 	struct passwd pw;
 	const char *usegroup = NULL;
+	USE_SMACK(char *smack = SMACKSTAR;)
+	USE_SMACK(char *cp;)
+	USE_SMACK(int rc;)
 
 	/* got root? */
 	if (geteuid()) {
@@ -182,7 +185,11 @@ int adduser_main(int argc, char **argv)
 
 	/* exactly one non-option arg */
 	opt_complementary = "=1";
+#if ENABLE_SMACK
+	getopt32(argv, "h:g:s:G:L:DSH", &pw.pw_dir, &pw.pw_gecos, &pw.pw_shell, &usegroup, &smack);
+#else
 	getopt32(argv, "h:g:s:G:DSH", &pw.pw_dir, &pw.pw_gecos, &pw.pw_shell, &usegroup);
+#endif
 	argv += optind;
 
 	/* create a passwd struct */
@@ -195,6 +202,16 @@ int adduser_main(int argc, char **argv)
 	pw.pw_uid = 0;
 	pw.pw_gid = usegroup ? xgroup2gid(usegroup) : 0; /* exits on failure */
 
+#if ENABLE_SMACK
+	if (smack_user_add(pw.pw_name, smack) < 0)
+		bb_error_msg("cannot add user smack entry");
+	if ((rc = adduser(&pw)) == 0)
+		if ((cp = strtok(smack, " \t")) != NULL)
+			if (smack_to_file(pw.pw_dir, smack, 0) != 0)
+				bb_error_msg("cannot set smack on home directory");
+	return rc;
+#else
 	/* grand finale */
 	return adduser(&pw);
+#endif
 }
diff -uprN busybox-1.7.2/loginutils/login.c busybox-1.7.2-smack/loginutils/login.c
--- busybox-1.7.2/loginutils/login.c	2007-09-29 16:54:12.000000000 -0700
+++ busybox-1.7.2-smack/loginutils/login.c	2008-05-30 10:38:07.000000000 -0700
@@ -242,6 +242,7 @@ int login_main(int argc, char **argv)
 	USE_PAM(pam_handle_t *pamh;)
 	USE_PAM(int pamret;)
 	USE_PAM(const char *failed_msg;)
+	USE_SMACK(char smack[SMACKBUFFSIZE];);
 
 	short_tty = full_tty;
 	username[0] = '\0';
@@ -406,6 +407,12 @@ int login_main(int argc, char **argv)
 		}
 	}
 #endif
+#if ENABLE_SMACK
+	if (smack_user_default(pw->pw_name, smack, SMACKBUFFSIZE) < 0)
+		strcpy(smack, SMACKFLOOR);
+	if (smack_to_proc(-1, smack) < 0)
+		bb_perror_msg_and_die("cannot set smack");
+#endif
 	/* Try these, but don't complain if they fail.
 	 * _f_chown is safe wrt race t=ttyname(0);...;chown(t); */
 	fchown(0, pw->pw_uid, pw->pw_gid);
diff -uprN busybox-1.7.2/loginutils/su.c busybox-1.7.2-smack/loginutils/su.c
--- busybox-1.7.2/loginutils/su.c	2007-09-03 04:48:47.000000000 -0700
+++ busybox-1.7.2-smack/loginutils/su.c	2008-05-29 14:25:15.000000000 -0700
@@ -22,6 +22,7 @@ int su_main(int argc, char **argv)
 	uid_t cur_uid = getuid();
 	const char *tty;
 	char *old_user;
+	USE_SMACK(char smack[SMACKBUFFSIZE];)
 
 	flags = getopt32(argv, "mplc:s:", &opt_command, &opt_shell);
 	argc -= optind;
@@ -95,6 +96,12 @@ int su_main(int argc, char **argv)
 	change_identity(pw);
 	setup_environment(opt_shell, flags & SU_OPT_l, !(flags & SU_OPT_mp), pw);
 	USE_SELINUX(set_current_security_context(NULL);)
+#if ENABLE_SMACK
+	if (smack_from_proc(-1, smack, SMACKBUFFSIZE) < 0)
+		bb_error_msg_and_die("cannot identify process smack");
+	if (smack_user_allowed(pw->pw_name, smack) < 0)
+		bb_error_msg_and_die("new usr not allowed current smack");
+#endif
 
 	/* Never returns */
 	run_shell(opt_shell, flags & SU_OPT_l, opt_command, (const char**)argv);
diff -uprN busybox-1.7.2/loginutils/sulogin.c busybox-1.7.2-smack/loginutils/sulogin.c
--- busybox-1.7.2/loginutils/sulogin.c	2007-09-03 04:48:47.000000000 -0700
+++ busybox-1.7.2-smack/loginutils/sulogin.c	2008-05-30 10:41:31.000000000 -0700
@@ -49,6 +49,7 @@ int sulogin_main(int argc, char **argv)
 	struct spwd spw;
 	struct spwd *result;
 #endif
+	USE_SMACK(char smack[SMACKBUFFSIZE];)
 
 	logmode = LOGMODE_BOTH;
 	openlog(applet_name, 0, LOG_AUTH);
@@ -110,6 +111,10 @@ int sulogin_main(int argc, char **argv)
 	bb_info_msg("System Maintenance Mode");
 
 	USE_SELINUX(renew_current_security_context());
+#if ENABLE_SMACK
+	if (smack_to_proc(-1, SMACKFLOOR) < 0)
+		bb_error_msg("login incorrect");
+#endif
 
 	shell = getenv("SUSHELL");
 	if (!shell) shell = getenv("sushell");
diff -uprN busybox-1.7.2/Makefile busybox-1.7.2-smack/Makefile
--- busybox-1.7.2/Makefile	2007-09-29 16:54:25.000000000 -0700
+++ busybox-1.7.2-smack/Makefile	2008-05-27 21:33:33.000000000 -0700
@@ -449,6 +449,7 @@ libs-y		:= \
 		procps/ \
 		runit/ \
 		selinux/ \
+		smack/ \
 		shell/ \
 		sysklogd/ \
 		util-linux/ \
diff -uprN busybox-1.7.2/miscutils/crond.c busybox-1.7.2-smack/miscutils/crond.c
--- busybox-1.7.2/miscutils/crond.c	2007-09-03 04:48:45.000000000 -0700
+++ busybox-1.7.2-smack/miscutils/crond.c	2008-05-30 14:24:19.000000000 -0700
@@ -917,10 +917,22 @@ static void RunJob(const char *user, Cro
 {
 	/* Fork as the user in question and run program */
 	pid_t pid = fork();
+	USE_SMACK(char smack[SMACKBUFFSIZE];)
 
 	if (pid == 0) {
 		/* CHILD */
 
+#if ENABLE_SMACK
+		if (smack_user_default(user, smack, SMACKBUFFSIZE) < 0) {
+			crondlog("\024user %s default smack unknown\n", user);
+			exit(0);
+		}
+		if (smack_to_proc(-1, smack) < 0) {
+			crondlog("\024user %s smack unsettable\n", user);
+			exit(0);
+		}
+#endif
+
 		/* Change running state to the user in question */
 
 		if (ChangeUser(user) < 0) {
diff -uprN busybox-1.7.2/miscutils/crontab.c busybox-1.7.2-smack/miscutils/crontab.c
--- busybox-1.7.2/miscutils/crontab.c	2007-09-03 04:48:45.000000000 -0700
+++ busybox-1.7.2-smack/miscutils/crontab.c	2008-05-30 11:59:31.000000000 -0700
@@ -42,6 +42,10 @@ int crontab_main(int ac, char **av)
 	char caller[256];           /* user that ran program */
 	char buf[1024];
 	int UserId;
+#if ENABLE_SMACK
+	char psmack[SMACKBUFFSIZE];
+	char dsmack[SMACKBUFFSIZE];
+#endif
 
 	UserId = getuid();
 	pas = getpwuid(UserId);
@@ -120,6 +124,15 @@ int crontab_main(int ac, char **av)
 	if (pas == NULL)
 		bb_perror_msg_and_die("getpwuid");
 
+#if ENABLE_SMACK
+	if (smack_user_default(pas->pw_name, dsmack, SMACKBUFFSIZE) < 0)
+		bb_perror_msg_and_die("user default smack unknown");
+	if (smack_from_proc(-1, psmack, SMACKBUFFSIZE) < 0)
+		bb_perror_msg_and_die("user default smack unknown");
+	if (strcmp(dsmack, psmack) != 0)
+		bb_perror_msg_and_die("current smack is not default smack");
+#endif
+
 	/*
 	 * If there is a replacement file, obtain a secure descriptor to it.
 	 */
diff -uprN busybox-1.7.2/procps/ps.c busybox-1.7.2-smack/procps/ps.c
--- busybox-1.7.2/procps/ps.c	2007-09-03 04:48:55.000000000 -0700
+++ busybox-1.7.2-smack/procps/ps.c	2008-05-27 21:33:33.000000000 -0700
@@ -80,6 +80,13 @@ static void func_label(char *buf, int si
 }
 #endif
 
+#if ENABLE_SMACK
+static void func_label(char *buf, int size, const procps_status_t *ps)
+{
+	safe_strncpy(buf, ps->context[0] ? ps->context : "?", size+1);
+}
+#endif
+
 /*
 static void func_nice(char *buf, int size, const procps_status_t *ps)
 {
@@ -131,12 +138,22 @@ static const ps_out_t out_spec[] = {
 #if ENABLE_SELINUX
 	{ 35                 , "label" ,"LABEL"  ,func_label ,PSSCAN_CONTEXT },
 #endif
+#if ENABLE_SMACK
+	{ 24                 , "label" ,"LABEL"  ,func_label ,PSSCAN_CONTEXT },
+#endif
 };
 
 #if ENABLE_SELINUX
 #define SELINIX_O_PREFIX "label,"
 #define DEFAULT_O_STR    SELINIX_O_PREFIX "pid,user" /* TODO: ,vsz,stat */ ",args"
-#else
+#endif
+
+#if ENABLE_SMACK
+#define SMACK_O_PREFIX "label,"
+#define DEFAULT_O_STR    SMACK_O_PREFIX "pid,user" /* TODO: ,vsz,stat */ ",args"
+#endif
+
+#if !ENABLE_SELINUX && !ENABLE_SMACK
 #define DEFAULT_O_STR    "pid,user" /* TODO: ,vsz,stat */ ",args"
 #endif
 
@@ -284,6 +301,7 @@ int ps_main(int argc, char **argv)
 	procps_status_t *p;
 	llist_t* opt_o = NULL;
 	USE_SELINUX(int opt;)
+	USE_SMACK(int opt;)
 
 	// POSIX:
 	// -a  Write information for all processes associated with terminals
@@ -297,7 +315,13 @@ int ps_main(int argc, char **argv)
 	//     Select which columns to display
 	/* We allow (and ignore) most of the above. FIXME */
 	opt_complementary = "o::";
-	USE_SELINUX(opt =) getopt32(argv, "Zo:aAdefl", &opt_o);
+#if ENABLE_SELINUX
+	opt = getopt32(argv, "Zo:aAdefl", &opt_o);
+#elif ENABLE_SMACK
+	opt = getopt32(argv, "Zo:aAdefl", &opt_o);
+#else
+	getopt32(argv, "Zo:aAdefl", &opt_o);
+#endif
 	if (opt_o) {
 		do {
 			parse_o(opt_o->data);
@@ -311,6 +335,12 @@ int ps_main(int argc, char **argv)
 			strcpy(default_o, DEFAULT_O_STR + sizeof(SELINIX_O_PREFIX)-1);
 		} else
 #endif
+#if ENABLE_SMACK
+		if (!(opt & 1)) {
+			/* no -Z : do not show LABEL */
+			strcpy(default_o, DEFAULT_O_STR + sizeof(SMACK_O_PREFIX)-1);
+		} else
+#endif
 		{
 			strcpy(default_o, DEFAULT_O_STR);
 		}
@@ -347,6 +377,8 @@ int ps_main(int argc, char **argv)
 	int len;
 	SKIP_SELINUX(const) int use_selinux = 0;
 	USE_SELINUX(int i;)
+	SKIP_SMACK(const) int use_smack = 0;
+	USE_SMACK(int i;)
 #if !ENABLE_FEATURE_PS_WIDE
 	enum { terminal_width = 79 };
 #else
@@ -378,8 +410,16 @@ int ps_main(int argc, char **argv)
 #endif
 #endif /* ENABLE_FEATURE_PS_WIDE || ENABLE_SELINUX */
 
+#if ENABLE_SMACK
+	i = getopt32(argv, "Z");
+	if (i & 1)
+		use_smack = PSSCAN_CONTEXT;
+#endif
+
 	if (use_selinux)
 		puts("  PID Context                          Stat Command");
+	if (use_smack)
+		puts("  PID Context                  Stat Command");
 	else
 		puts("  PID  Uid        VSZ Stat Command");
 
@@ -390,6 +430,7 @@ int ps_main(int argc, char **argv)
 			| PSSCAN_VSZ
 			| PSSCAN_COMM
 			| use_selinux
+			| use_smack
 	))) {
 #if ENABLE_SELINUX
 		if (use_selinux) {
@@ -399,6 +440,14 @@ int ps_main(int argc, char **argv)
 					p->state);
 		} else
 #endif
+#if ENABLE_SMACK
+		if (use_smack) {
+			len = printf("%5u %-24s %s ",
+					p->pid,
+					p->context[0] ? p->context : "?",
+					p->state);
+		} else
+#endif
 		{
 			const char *user = get_cached_username(p->uid);
 			if (p->vsz == 0)
diff -uprN busybox-1.7.2/smack/Config.in busybox-1.7.2-smack/smack/Config.in
--- busybox-1.7.2/smack/Config.in	1969-12-31 16:00:00.000000000 -0800
+++ busybox-1.7.2-smack/smack/Config.in	2008-05-27 21:33:33.000000000 -0700
@@ -0,0 +1,38 @@
+#
+# For a description of the syntax of this configuration file,
+# see scripts/kbuild/config-language.txt.
+#
+
+menu "Smack Utilities"
+	depends on SMACK
+
+config SMACKLOAD
+	bool "smackload"
+	default n
+	depends on SMACK
+	help
+	  Enable support to load Smack access rules.
+
+config SMACKCIPSO
+	bool "smackcipso"
+	default n
+	depends on SMACK
+	help
+	  Enable support to specify Smack CIPSO mappings.
+
+config NEWSMACK
+	bool "newsmack"
+	default n
+	depends on SMACK
+	help
+	  Enable support to run command with specified Smack label.
+
+config SMACKENABLED
+	bool "smackenabled"
+	default n
+	depends on SMACK
+	help
+	  Enable support for this command to be used within shell scripts
+	  to determine if smack is enabled.
+
+endmenu
diff -uprN busybox-1.7.2/smack/Kbuild busybox-1.7.2-smack/smack/Kbuild
--- busybox-1.7.2/smack/Kbuild	1969-12-31 16:00:00.000000000 -0800
+++ busybox-1.7.2-smack/smack/Kbuild	2008-05-27 21:33:33.000000000 -0700
@@ -0,0 +1,12 @@
+# Makefile for busybox
+#
+# Copyright (C) 1999-2005 by Erik Andersen <andersen@codepoet.org>
+# Copyright (C) 2007 by KaiGai Kohei <kaigai@kaigai.gr.jp>
+#
+# Licensed under the GPL v2, see the file LICENSE in this tarball.
+
+lib-y:=
+lib-$(CONFIG_NEWSMACK)		+= newsmack.o
+lib-$(CONFIG_SMACKLOAD)		+= smackload.o
+lib-$(CONFIG_SMACKCIPSO)	+= smackcipso.o
+lib-$(CONFIG_SMACKENABLED)	+= smackenabled.o
diff -uprN busybox-1.7.2/smack/newsmack.c busybox-1.7.2-smack/smack/newsmack.c
--- busybox-1.7.2/smack/newsmack.c	1969-12-31 16:00:00.000000000 -0800
+++ busybox-1.7.2-smack/smack/newsmack.c	2008-05-28 17:26:04.000000000 -0700
@@ -0,0 +1,61 @@
+/*
+ * newsmack label [ command [ arg ] ... ]
+ *
+ * Port to busybox: Casey Schaufler <casey@schaufler-ca.com>
+ *
+ * Copyright (C) 2007 Casey Schaufler <casey@schaufler-ca.com>
+ *
+ */
+
+#include "libbb.h"
+
+int newsmack_main(int argc, char **argv);
+int newsmack_main(int argc, char **argv)
+{
+	struct passwd *pwd;
+	char *newargv[256]; /* yes, I know */
+	char *smack;
+	int i;
+	int newargc;
+
+	if (argc <= 1)
+		bb_error_msg_and_die("No smack value specified");
+
+	smack = argv[1];
+
+	/*
+	 * Start a shell if no command is specified
+	 */
+	if (argc == 2) {
+		fprintf(stderr, "%s: start a shell at \"%s\"\n",
+			argv[0], smack);
+		newargv[0] = strdup("sh");
+		newargv[1] = NULL;
+	} else {
+		for (newargc = 0, i = 2; i < argc; newargc++, i++)
+			newargv[newargc] = argv[i];
+		newargv[newargc] = NULL;
+	}
+
+	/*
+	 * Verify the user is allowed the Smack label
+	 */
+	pwd = getpwuid(getuid());
+	if (pwd == NULL)
+		bb_error_msg_and_die("User name not obtained");
+	if (smack_user_allowed(pwd->pw_name, smack) != 0)
+		bb_error_msg_and_die("User not allowed this smack label");
+	/*
+	 * Set the process label.
+	 */
+	i = smack_to_proc(-1, smack);
+	if (i < 0)
+		bb_error_msg_and_die("Cannot set smack");
+
+	/*
+	 * Do the exec
+	 */
+	execvp(newargv[0], newargv);
+
+	bb_error_msg_and_die("%s: exec failure.", newargv[0]);
+}
diff -uprN busybox-1.7.2/smack/smackcipso.c busybox-1.7.2-smack/smack/smackcipso.c
--- busybox-1.7.2/smack/smackcipso.c	1969-12-31 16:00:00.000000000 -0800
+++ busybox-1.7.2-smack/smack/smackcipso.c	2008-05-27 21:33:33.000000000 -0700
@@ -0,0 +1,119 @@
+/*
+ * smackcipso - properly format smack access cipsos for
+ * loading into the kernel by writing to /smack/cipso.
+ *
+ * Copyright (C) 2007 Casey Schaufler <casey@schaufler-ca.com>
+ *
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License as published by
+ *	the Free Software Foundation, version 2.
+ *
+ * Authors:
+ *	Casey Schaufler <casey@schaufler-ca.com>
+ *	Ahmed S. Darwish <darwish.07@gmail.com>
+ *
+ */
+/*
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+*/
+#include "libbb.h"
+
+#define LSIZE 23
+#define NSIZE 4
+#define MAXCATNUM 239
+#define MAXCATVAL 63
+#define MAXLEVEL 255
+
+int smackcipso_main(int argc, char **argv);
+int smackcipso_main(int argc, char **argv)
+{
+	int status = EXIT_SUCCESS;
+	int cipsofd;
+	char line[512];
+	char cipso[LSIZE + NSIZE + NSIZE + (NSIZE * MAXCATNUM)];
+	char cats[MAXCATNUM+1][NSIZE+1];
+	char *cp;
+	int level;
+	int cat;
+	int catcount;
+	int i;
+	int err;
+
+	cipsofd = open("/smack/cipso", O_RDWR);
+	if (cipsofd < 0)
+		bb_error_msg_and_die("failed opening /smack/cipso");
+
+	while (fgets(line, sizeof(line), stdin) != NULL) {
+		catcount = 0;
+		err = 0;
+
+		if ((cp = strchr(line, '\n')) == NULL) {
+			fprintf(stderr, "missing newline \"%s\"\n", line);
+			continue;
+		}
+		*cp = '\0';
+		cp = strtok(line, " \t");
+		if (cp == NULL) {
+			fprintf(stderr, "Empty line: \"%s\"\n", line);
+			continue;
+		}
+		sprintf(cipso, "%-23s ", line);
+		if (strlen(cipso) != 24) {
+			fprintf(stderr, "Bad label starting: \"%s\"\n", line);
+			continue;
+		}
+		cp = strtok(NULL, " \t");
+		if (cp == NULL) {
+			fprintf(stderr, "Missing level: \"%s\"\n", line);
+			continue;
+		}
+		if (!isdigit(*cp)) {
+			fprintf(stderr, "Bad level: \"%s\"\n", cp);
+			continue;
+		}
+		level = atoi(cp);
+		if (level > MAXLEVEL) {
+			fprintf(stderr, "Bad level: \"%s\"\n", cp);
+			continue;
+		}
+		sprintf(cipso+LSIZE+1, "%-4d", level);
+
+		cp = strtok(NULL, " \t");
+		for (i = 0; cp != NULL; cp = strtok(NULL, " \t"), i++) {
+			if (!isdigit(*cp)) {
+				fprintf(stderr, "Bad category \"%s\"\n", cp);
+				err = 1;
+				break;
+			}
+			cat = atoi(cp);
+			if (i >= MAXCATNUM) {
+				fprintf(stderr, "Maximum number of categories"
+					"exceeded \"%d\"\n", i);
+				err = 1;
+				break;
+			}
+			if (cat > MAXCATVAL) {
+				fprintf(stderr, "Bad category \"%s\"\n", cp);
+				err = 1;
+				break;
+			}
+			sprintf(cats[i], "%-4d", cat);
+		}
+		if (err)
+			continue;
+
+		sprintf(cipso+LSIZE+1+NSIZE, "%-4d", i);
+		while (i > 0)
+			strcat(cipso, cats[--i]);
+		err = write(cipsofd, cipso, strlen(cipso));
+		if (err < 0)
+			perror("writing /smack/cipso");
+	}
+	return status;
+}
diff -uprN busybox-1.7.2/smack/smackenabled.c busybox-1.7.2-smack/smack/smackenabled.c
--- busybox-1.7.2/smack/smackenabled.c	1969-12-31 16:00:00.000000000 -0800
+++ busybox-1.7.2-smack/smack/smackenabled.c	2008-05-27 21:33:33.000000000 -0700
@@ -0,0 +1,17 @@
+/*
+ * smackenabled
+ *
+ * Port to BusyBox  Casey Schaufler <casey@schaufler-ca.com
+ *
+ */
+#include "libbb.h"
+
+int smackenabled_main(int argc, char **argv);
+int smackenabled_main(int argc, char **argv)
+{
+	char buffer[80];
+
+	if (smack_from_file("/", buffer, sizeof(buffer), 0) < 0)
+		return 0;
+	return 1;
+}
diff -uprN busybox-1.7.2/smack/smackload.c busybox-1.7.2-smack/smack/smackload.c
--- busybox-1.7.2/smack/smackload.c	1969-12-31 16:00:00.000000000 -0800
+++ busybox-1.7.2-smack/smack/smackload.c	2008-05-27 21:33:33.000000000 -0700
@@ -0,0 +1,93 @@
+/*
+ * smackload - properly format smack access rules for
+ * loading into the kernel by writing to /smack/load.
+ *
+ * Copyright (C) 2007 Casey Schaufler <casey@schaufler-ca.com>
+ *
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License as published by
+ *	the Free Software Foundation, version 2.
+ *
+ * Author:
+ *	Casey Schaufler <casey@schaufler-ca.com>
+ */
+/*
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+*/
+#include "libbb.h"
+
+#define LSIZE 23
+#define ASIZE 4
+
+int smackload_main(int argc, char **argv);
+int smackload_main(int argc, char **argv)
+{
+	int status = EXIT_SUCCESS;
+	int loadfd;
+	char line[80];
+	char rule[LSIZE + LSIZE + ASIZE + 3];
+	char subject[LSIZE+1];
+	char object[LSIZE+1];
+	char accesses[ASIZE+1];
+	char real[ASIZE+1];
+	char *cp;
+	int i;
+	int err;
+
+	loadfd = open("/smack/load", O_RDWR);
+	if (loadfd < 0)
+		bb_error_msg_and_die("failed opening /smack/load");
+
+	while (fgets(line, 80, stdin) != NULL) {
+		err = 0;
+		if ((cp = strchr(line, '\n')) != NULL)
+			*cp = '\0';
+		if (sscanf(line,"%23s %23s %4s",subject,object,accesses) != 3) 
+			err = 1;
+		else {
+			strcpy(real, "----");
+			for (i = 0;
+			     i < ASIZE && accesses[i] != '\0' && err == 0;
+			     i++) {
+				switch (accesses[i]) {
+				case 'r':
+				case 'R':
+					real[0] = 'r';
+					break;
+				case 'w':
+				case 'W':
+					real[1] = 'w';
+					break;
+				case 'x':
+				case 'X':
+					real[2] = 'x';
+					break;
+				case 'a':
+				case 'A':
+					real[3] = 'a';
+					break;
+				case '\0':
+				case '-':
+					break;
+				default:
+					err = 1;
+					break;
+				}
+			}
+		}
+		if (err == 0) {
+			sprintf(rule, "%-23s %-23s %4s", subject,object,real);
+			err = write(loadfd, rule, LSIZE + LSIZE + ASIZE + 2);
+			if (err < 0)
+				perror("writing /smack/load");
+		}
+		else
+			fprintf(stderr, "Bad input line \"%s\"\n", line);
+	}
+	return status;
+}
